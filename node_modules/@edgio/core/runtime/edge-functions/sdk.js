"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/runtime/edge-functions/bundled-object-inspect.js
var require_bundled_object_inspect = __commonJS({
  "src/runtime/edge-functions/bundled-object-inspect.js"(exports2, module2) {
    "use strict";
    var Et = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
    var et = Et(() => {
    });
    var U = typeof Map == "function" && Map.prototype;
    var N = Object.getOwnPropertyDescriptor && U ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var I = U && N && typeof N.get == "function" ? N.get : null;
    var rt = U && Map.prototype.forEach;
    var K = typeof Set == "function" && Set.prototype;
    var C = Object.getOwnPropertyDescriptor && K ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var L = K && C && typeof C.get == "function" ? C.get : null;
    var nt = K && Set.prototype.forEach;
    var $t = typeof WeakMap == "function" && WeakMap.prototype;
    var w = $t ? WeakMap.prototype.has : null;
    var Mt = typeof WeakSet == "function" && WeakSet.prototype;
    var E = Mt ? WeakSet.prototype.has : null;
    var Wt = typeof WeakRef == "function" && WeakRef.prototype;
    var at = Wt ? WeakRef.prototype.deref : null;
    var It = Boolean.prototype.valueOf;
    var Lt = Object.prototype.toString;
    var _t = Function.prototype.toString;
    var Rt = String.prototype.match;
    var Q = String.prototype.slice;
    var s = String.prototype.replace;
    var kt = String.prototype.toUpperCase;
    var it = String.prototype.toLowerCase;
    var gt = RegExp.prototype.test;
    var ot = Array.prototype.concat;
    var u = Array.prototype.join;
    var qt = Array.prototype.slice;
    var ft = Math.floor;
    var z = typeof BigInt == "function" ? BigInt.prototype.valueOf : null;
    var B = Object.getOwnPropertySymbols;
    var F = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null;
    var m = typeof Symbol == "function" && typeof Symbol.iterator == "object";
    var o = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === m ? "object" : "symbol") ? Symbol.toStringTag : null;
    var vt = Object.prototype.propertyIsEnumerable;
    var lt = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
      return t.__proto__;
    } : null);
    function ut(t, e) {
      if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || gt.call(/e/, e))
        return e;
      var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof t == "number") {
        var a = t < 0 ? -ft(-t) : ft(t);
        if (a !== t) {
          var i = String(a), r = Q.call(e, i.length + 1);
          return s.call(i, n, "$&_") + "." + s.call(s.call(r, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return s.call(e, n, "$&_");
    }
    var H = et();
    var ct = H.custom;
    var pt = ht(ct) ? ct : null;
    module2.exports = function t(e, n, a, i) {
      var r = n || {};
      if (y(r, "quoteStyle") && r.quoteStyle !== "single" && r.quoteStyle !== "double")
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      if (y(r, "maxStringLength") && (typeof r.maxStringLength == "number" ? r.maxStringLength < 0 && r.maxStringLength !== 1 / 0 : r.maxStringLength !== null))
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      var c = y(r, "customInspect") ? r.customInspect : true;
      if (typeof c != "boolean" && c !== "symbol")
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      if (y(r, "indent") && r.indent !== null && r.indent !== "	" && !(parseInt(r.indent, 10) === r.indent && r.indent > 0))
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      if (y(r, "numericSeparator") && typeof r.numericSeparator != "boolean")
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      var v = r.numericSeparator;
      if (typeof e > "u")
        return "undefined";
      if (e === null)
        return "null";
      if (typeof e == "boolean")
        return e ? "true" : "false";
      if (typeof e == "string")
        return dt(e, r);
      if (typeof e == "number") {
        if (e === 0)
          return 1 / 0 / e > 0 ? "0" : "-0";
        var f = String(e);
        return v ? ut(e, f) : f;
      }
      if (typeof e == "bigint") {
        var p = String(e) + "n";
        return v ? ut(e, p) : p;
      }
      var _ = typeof r.depth > "u" ? 5 : r.depth;
      if (typeof a > "u" && (a = 0), a >= _ && _ > 0 && typeof e == "object")
        return V(e) ? "[Array]" : "[Object]";
      var S = Yt(r, a);
      if (typeof i > "u")
        i = [];
      else if (mt(i, e) >= 0)
        return "[Circular]";
      function l(h, M, wt) {
        if (M && (i = qt.call(i), i.push(M)), wt) {
          var tt = { depth: r.depth };
          return y(r, "quoteStyle") && (tt.quoteStyle = r.quoteStyle), t(h, tt, a + 1, i);
        }
        return t(h, r, a + 1, i);
      }
      if (typeof e == "function" && !yt(e)) {
        var G = Ft(e), X = W(e, l);
        return "[Function" + (G ? ": " + G : " (anonymous)") + "]" + (X.length > 0 ? " { " + u.call(X, ", ") + " }" : "");
      }
      if (ht(e)) {
        var Y = m ? s.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : F.call(e);
        return typeof e == "object" && !m ? O(Y) : Y;
      }
      if (Qt(e)) {
        for (var d = "<" + it.call(String(e.nodeName)), R = e.attributes || [], $ = 0; $ < R.length; $++)
          d += " " + R[$].name + "=" + St(At(R[$].value), "double", r);
        return d += ">", e.childNodes && e.childNodes.length && (d += "..."), d += "</" + it.call(String(e.nodeName)) + ">", d;
      }
      if (V(e)) {
        if (e.length === 0)
          return "[]";
        var k = W(e, l);
        return S && !Xt(k) ? "[" + J(k, S) + "]" : "[ " + u.call(k, ", ") + " ]";
      }
      if (Dt(e)) {
        var q = W(e, l);
        return !("cause" in Error.prototype) && "cause" in e && !vt.call(e, "cause") ? "{ [" + String(e) + "] " + u.call(ot.call("[cause]: " + l(e.cause), q), ", ") + " }" : q.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + u.call(q, ", ") + " }";
      }
      if (typeof e == "object" && c) {
        if (pt && typeof e[pt] == "function" && H)
          return H(e, { depth: _ - a });
        if (c !== "symbol" && typeof e.inspect == "function")
          return e.inspect();
      }
      if (Ht(e)) {
        var Z = [];
        return rt && rt.call(e, function(h, M) {
          Z.push(l(M, e, true) + " => " + l(h, e));
        }), st("Map", I.call(e), Z, S);
      }
      if (Ut(e)) {
        var x = [];
        return nt && nt.call(e, function(h) {
          x.push(l(h, e));
        }), st("Set", L.call(e), x, S);
      }
      if (Vt(e))
        return P("WeakMap");
      if (Kt(e))
        return P("WeakSet");
      if (Jt(e))
        return P("WeakRef");
      if (Ct(e))
        return O(l(Number(e)));
      if (Pt(e))
        return O(l(z.call(e)));
      if (Bt(e))
        return O(It.call(e));
      if (Nt(e))
        return O(l(String(e)));
      if (!Tt(e) && !yt(e)) {
        var A = W(e, l), b = lt ? lt(e) === Object.prototype : e instanceof Object || e.constructor === Object, T = e instanceof Object ? "" : "null prototype", j = !b && o && Object(e) === e && o in e ? Q.call(g(e), 8, -1) : T ? "Object" : "", Ot = b || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", D = Ot + (j || T ? "[" + u.call(ot.call([], j || [], T || []), ": ") + "] " : "");
        return A.length === 0 ? D + "{}" : S ? D + "{" + J(A, S) + "}" : D + "{ " + u.call(A, ", ") + " }";
      }
      return String(e);
    };
    function St(t, e, n) {
      var a = (n.quoteStyle || e) === "double" ? '"' : "'";
      return a + t + a;
    }
    function At(t) {
      return s.call(String(t), /"/g, "&quot;");
    }
    function V(t) {
      return g(t) === "[object Array]" && (!o || !(typeof t == "object" && o in t));
    }
    function Tt(t) {
      return g(t) === "[object Date]" && (!o || !(typeof t == "object" && o in t));
    }
    function yt(t) {
      return g(t) === "[object RegExp]" && (!o || !(typeof t == "object" && o in t));
    }
    function Dt(t) {
      return g(t) === "[object Error]" && (!o || !(typeof t == "object" && o in t));
    }
    function Nt(t) {
      return g(t) === "[object String]" && (!o || !(typeof t == "object" && o in t));
    }
    function Ct(t) {
      return g(t) === "[object Number]" && (!o || !(typeof t == "object" && o in t));
    }
    function Bt(t) {
      return g(t) === "[object Boolean]" && (!o || !(typeof t == "object" && o in t));
    }
    function ht(t) {
      if (m)
        return t && typeof t == "object" && t instanceof Symbol;
      if (typeof t == "symbol")
        return true;
      if (!t || typeof t != "object" || !F)
        return false;
      try {
        return F.call(t), true;
      } catch {
      }
      return false;
    }
    function Pt(t) {
      if (!t || typeof t != "object" || !z)
        return false;
      try {
        return z.call(t), true;
      } catch {
      }
      return false;
    }
    var zt = Object.prototype.hasOwnProperty || function(t) {
      return t in this;
    };
    function y(t, e) {
      return zt.call(t, e);
    }
    function g(t) {
      return Lt.call(t);
    }
    function Ft(t) {
      if (t.name)
        return t.name;
      var e = Rt.call(_t.call(t), /^function\s*([\w$]+)/);
      return e ? e[1] : null;
    }
    function mt(t, e) {
      if (t.indexOf)
        return t.indexOf(e);
      for (var n = 0, a = t.length; n < a; n++)
        if (t[n] === e)
          return n;
      return -1;
    }
    function Ht(t) {
      if (!I || !t || typeof t != "object")
        return false;
      try {
        I.call(t);
        try {
          L.call(t);
        } catch {
          return true;
        }
        return t instanceof Map;
      } catch {
      }
      return false;
    }
    function Vt(t) {
      if (!w || !t || typeof t != "object")
        return false;
      try {
        w.call(t, w);
        try {
          E.call(t, E);
        } catch {
          return true;
        }
        return t instanceof WeakMap;
      } catch {
      }
      return false;
    }
    function Jt(t) {
      if (!at || !t || typeof t != "object")
        return false;
      try {
        return at.call(t), true;
      } catch {
      }
      return false;
    }
    function Ut(t) {
      if (!L || !t || typeof t != "object")
        return false;
      try {
        L.call(t);
        try {
          I.call(t);
        } catch {
          return true;
        }
        return t instanceof Set;
      } catch {
      }
      return false;
    }
    function Kt(t) {
      if (!E || !t || typeof t != "object")
        return false;
      try {
        E.call(t, E);
        try {
          w.call(t, w);
        } catch {
          return true;
        }
        return t instanceof WeakSet;
      } catch {
      }
      return false;
    }
    function Qt(t) {
      return !t || typeof t != "object" ? false : typeof HTMLElement < "u" && t instanceof HTMLElement ? true : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
    }
    function dt(t, e) {
      if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength, a = "... " + n + " more character" + (n > 1 ? "s" : "");
        return dt(Q.call(t, 0, e.maxStringLength), e) + a;
      }
      var i = s.call(s.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Gt);
      return St(i, "single", e);
    }
    function Gt(t) {
      var e = t.charCodeAt(0), n = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[e];
      return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + kt.call(e.toString(16));
    }
    function O(t) {
      return "Object(" + t + ")";
    }
    function P(t) {
      return t + " { ? }";
    }
    function st(t, e, n, a) {
      var i = a ? J(n, a) : u.call(n, ", ");
      return t + " (" + e + ") {" + i + "}";
    }
    function Xt(t) {
      for (var e = 0; e < t.length; e++)
        if (mt(t[e], `
`) >= 0)
          return false;
      return true;
    }
    function Yt(t, e) {
      var n;
      if (t.indent === "	")
        n = "	";
      else if (typeof t.indent == "number" && t.indent > 0)
        n = u.call(Array(t.indent + 1), " ");
      else
        return null;
      return { base: n, prev: u.call(Array(e + 1), n) };
    }
    function J(t, e) {
      if (t.length === 0)
        return "";
      var n = `
` + e.prev + e.base;
      return n + u.call(t, "," + n) + `
` + e.prev;
    }
    function W(t, e) {
      var n = V(t), a = [];
      if (n) {
        a.length = t.length;
        for (var i = 0; i < t.length; i++)
          a[i] = y(t, i) ? e(t[i], t) : "";
      }
      var r = typeof B == "function" ? B(t) : [], c;
      if (m) {
        c = {};
        for (var v = 0; v < r.length; v++)
          c["$" + r[v]] = r[v];
      }
      for (var f in t)
        !y(t, f) || n && String(Number(f)) === f && f < t.length || m && c["$" + f] instanceof Symbol || (gt.call(/[^\w$]/, f) ? a.push(e(f, t) + ": " + e(t[f], t)) : a.push(f + ": " + e(t[f], t)));
      if (typeof B == "function")
        for (var p = 0; p < r.length; p++)
          vt.call(t, r[p]) && a.push("[" + e(r[p]) + "]: " + e(t[r[p]], t));
      return a;
    }
  }
});

// src/runtime/edge-functions/sdk.js
module.exports = function({ host, utility }, edgioRequestId, edgeFunctions) {
  const STDOUT_FD = 1;
  const STDERR_FD = 2;
  const ENV_VAR_NAMESPACE_EDGIO_CONFIG = "edgio-config";
  const ENV_VAR_NAMESPACE_EDGIO_ORIGINS = "edgio-origins";
  const ENV_VAR_NAMESPACE_EDGIO_USRVAR = "edgio-usrvar";
  const ENV_VAR_NAMESPACE_EDGIO_GEO = "edgio-geo";
  const ENV_VAR_NAMESPACE_EDGIO_WURFL = "edgio-wurfl";
  const ENV_VAR_NAMESPACE_EDGIO_VIRT = "edgio-virt";
  const UTF_8 = "utf-8";
  const WASM_METRIC_JSON_PARSE_INVOCATION_TOTAL = 1e3;
  const WASM_METRIC_JSON_STRINGIFY_INVOCATION_TOTAL = 1001;
  const WASM_METRIC_JSON_PARSE_MICROSECONDS_TOTAL = 1002;
  const WASM_METRIC_JSON_STRINGIFY_MICROSECONDS_TOTAL = 1003;
  const AppendFn = Symbol("append-fn");
  const BodyDefined = Symbol("body-defined");
  const BodyUsed = Symbol("body-used");
  const CheckFn = Symbol("check-fn");
  const Done = Symbol("done");
  const EdgioId = Symbol("edgio-id");
  const Encoding = Symbol("encoding");
  const ErrorCode = Symbol("error-code");
  const GetBody = Symbol("get-body");
  const GetFn = Symbol("get-fn");
  const KeysFn = Symbol("keys-fn");
  const Namespace = Symbol("namespace");
  const Options = Symbol("options");
  const Origins = Symbol("edgio-origins");
  const Redirected = Symbol("redirected");
  const RemoveFn = Symbol("remove-fn");
  const ReqRespHeaders = Symbol("req-resp-headers");
  const SetFn = Symbol("set-fn");
  const Url = Symbol("url");
  const InternalErrorPrefix = "Internal Error: ";
  const inspect = require_bundled_object_inspect();
  let consoleGroupIndentDepth = 0;
  const CONSOLE_GROUP_INDENT_STEP = 2;
  const getConsoleIndent = () => " ".repeat(consoleGroupIndentDepth);
  function wrappedConsoleWrite(fdWrite, ...args) {
    fdWrite(getConsoleIndent());
    if (args.length > 0) {
      let firstArg = args[0];
      if (typeof firstArg === "string") {
        args.shift();
        firstArg = firstArg.replace(/%[oOdisf]/g, (match) => {
          if (args.length === 0) {
            return match;
          }
          const arg = args.shift();
          switch (match) {
            case "%o":
            case "%O":
              return inspect(arg);
            case "%d":
            case "%i":
              return parseInt(arg, 10).toString();
            case "%s":
              return arg.toString();
            case "%f":
              return parseFloat(arg).toString();
            default:
              return match;
          }
        });
        args.unshift(firstArg);
      }
    }
    for (let i = 0; i < args.length; i++) {
      if (i !== 0) {
        fdWrite(" ");
      }
      const arg = args[i];
      const type = typeof arg;
      switch (type) {
        case "string":
          fdWrite(arg);
          break;
        case "number":
        case "function":
          fdWrite(arg.toString());
          break;
        case "boolean":
          fdWrite(arg ? "true" : "false");
          break;
        case "undefined":
          fdWrite(type);
          break;
        default:
          if (arg === null) {
            fdWrite("null");
          } else {
            fdWrite(inspect(arg));
          }
          break;
      }
    }
    fdWrite("\n");
  }
  function consoleWrite(fd, ...args) {
    const fdWrite = utility.stream_write_all.bind(this, fd);
    try {
      return wrappedConsoleWrite(fdWrite, ...args);
    } catch (e) {
      fdWrite("Exception during console output: ");
      fdWrite(e.toString());
      fdWrite("\n");
    }
  }
  const consoleCounters = /* @__PURE__ */ new Map();
  globalThis.console = {
    assert: function(condition, ...args) {
      if (!condition) {
        consoleWrite(STDERR_FD, "Assertion failed:", ...args);
      }
    },
    clear: function() {
    },
    count: function(label) {
      consoleCounters.set(label, (consoleCounters.get(label) || 0) + 1);
      globalThis.console.log(`${label}: ${consoleCounters.get(label)}`);
    },
    countReset: function(label) {
      consoleCounters.set(label, 0);
    },
    debug: consoleWrite.bind(globalThis.console, STDOUT_FD),
    dir: function(...args) {
      return globalThis.console.log(...args);
    },
    dirxml: function(...args) {
      return globalThis.console.log(...args);
    },
    error: consoleWrite.bind(globalThis.console, STDERR_FD),
    group: function(...args) {
      if (args !== void 0) {
        globalThis.console.log(...args);
      }
      consoleGroupIndentDepth += CONSOLE_GROUP_INDENT_STEP;
    },
    groupCollapsed: function(...args) {
      return globalThis.console.group(...args);
    },
    groupEnd: function() {
      consoleGroupIndentDepth = Math.max(consoleGroupIndentDepth - CONSOLE_GROUP_INDENT_STEP, 0);
    },
    info: consoleWrite.bind(globalThis.console, STDOUT_FD),
    log: consoleWrite.bind(globalThis.console, STDOUT_FD),
    profile: function() {
    },
    table: function(data, columns) {
      return globalThis.console.warn("table not implemented", data, columns);
    },
    time: function() {
    },
    timeEnd: function(label) {
      return globalThis.console.warn("timeEnd not implemented", label);
    },
    timeLog: function(label) {
      return globalThis.console.warn("timeLog not implemented", label);
    },
    timeStamp: function() {
    },
    trace: consoleWrite.bind(globalThis.console, STDOUT_FD),
    warn: consoleWrite.bind(globalThis.console, STDERR_FD)
  };
  const _EdgioReadableStreamReader = class {
    constructor(id, getBodyFn) {
      if (this.constructor == _EdgioReadableStreamReader) {
        throw new Error(`${InternalErrorPrefix}EdgioReadableStreamReader Abstract class cannot be instantiated directly.`);
      }
      this[EdgioId] = id;
      this[GetBody] = getBodyFn;
      this[Done] = false;
    }
    async read() {
      const body = new Uint8Array(this[GetBody](this[EdgioId]));
      this[Done] = true;
      return { value: body };
    }
  };
  let EdgioReadableStreamReader = _EdgioReadableStreamReader;
  __publicField(EdgioReadableStreamReader, "BUFFER_SIZE", 1024);
  class EdgioReadableResponseStreamReader extends EdgioReadableStreamReader {
    constructor(responseId) {
      super(responseId, host.hostcall_resp_get_body);
    }
  }
  class EdgioReadableRequestStreamReader extends EdgioReadableStreamReader {
    constructor(requestId) {
      super(requestId, host.hostcall_req_get_body);
    }
  }
  class EdgioReadableResponseStream {
    constructor(responseId) {
      this[EdgioId] = responseId;
    }
    getReader() {
      return new EdgioReadableResponseStreamReader(this[EdgioId]);
    }
  }
  class EdgioReadableRequestStream {
    constructor(requestId) {
      this[EdgioId] = requestId;
    }
    getReader() {
      return new EdgioReadableRequestStreamReader(this[EdgioId]);
    }
  }
  class EdgioHeaders {
    constructor(id, headers, { appendFn, checkFn, getFn, keysFn, removeFn, setFn }) {
      if (this.constructor == EdgioHeaders) {
        throw new Error(`${InternalErrorPrefix}Headers Abstract class cannot be instantiated directly.`);
      }
      this[EdgioId] = id;
      this[AppendFn] = appendFn;
      this[CheckFn] = checkFn;
      this[GetFn] = getFn;
      this[KeysFn] = keysFn;
      this[RemoveFn] = removeFn;
      this[SetFn] = setFn;
      if (Array.isArray(headers)) {
        headers.forEach((h) => {
          if (!Array.isArray(h)) {
            throw new Error(`When passing an array of headers, each array element must be an array of length = 2. '${h}' is type '${typeof h}' not type array.`);
          }
          if (h.length !== 2) {
            throw new Error(`When passing an array of headers, each array element must be an array of length = 2. '${h}' is array of length ${h.length}.`);
          }
          host.hostcall_debug(`.append(${h})`);
          this.append(h[0], h[1]);
        });
      } else if (headers && headers instanceof Headers) {
        const rawHeaders = headers.getRaw();
        Object.keys(rawHeaders).forEach((name) => {
          rawHeaders[name].forEach((value) => {
            this.append(name, value);
          });
        });
      } else if (headers && Function.prototype.toString.call(headers.constructor).match(/class.*/)) {
        throw new Error(`'headers' must be a 'Headers' instance, dictionary, or an array of array pairs. Found ${Function.prototype.toString.call(headers.constructor)}`);
      } else if (typeof headers === "object") {
        Object.keys(headers).forEach((name) => {
          this.append(name, headers[name]);
        });
      } else if (typeof headers !== "undefined") {
        throw new Error(`'headers' must be a dictionary or an array of array pairs. Found type ${typeof headers}.`);
      }
    }
    _validateName(name) {
      if (name === void 0) {
        throw new Error("The 'name' argument is required, but was not present.");
      }
      if (typeof name !== "string") {
        throw new Error(`The 'name' argument must be a 'string' type, not a '${typeof name}' type.`);
      }
      return name;
    }
    _validateValue(value) {
      if (value === void 0) {
        throw new Error("The 'value' argument is required, but was not present.");
      }
      if (typeof value !== "string" && !Array.isArray(value)) {
        throw new Error(`The 'value' argument must be a 'string' or 'array' type, not a '${typeof value}' type.`);
      }
      return value;
    }
    append(name, value) {
      this[AppendFn](this[EdgioId], this._validateName(name), this._validateValue(value));
    }
    delete(name) {
      this[RemoveFn](this[EdgioId], this._validateName(name));
    }
    entries() {
      const entries = [];
      for (const key of this.keys()) {
        entries.push([key, this.get(key)]);
      }
      return entries;
    }
    forEach(callback) {
      for (const key of this.keys()) {
        callback(this.get(key), key);
      }
    }
    get(name) {
      const headers = this[GetFn](this[EdgioId], this._validateName(name));
      if (Array.isArray(headers))
        return headers.join(", ");
      return typeof headers === "undefined" ? null : headers;
    }
    has(name) {
      return this[CheckFn](this[EdgioId], this._validateName(name));
    }
    keys() {
      return this[KeysFn](this[EdgioId]);
    }
    set(name, value) {
      this[SetFn](this[EdgioId], this._validateName(name), this._validateValue(value));
    }
    values() {
      const values = [];
      for (const key of this.keys()) {
        values.push(this.get(key));
      }
      return values;
    }
    toJSON() {
      const json = {};
      for (const key of this.keys()) {
        json[key] = this.get(key);
      }
      return json;
    }
  }
  class EdgioResponseHeaders extends EdgioHeaders {
    constructor(responseId, headers) {
      super(responseId, headers, {
        appendFn: host.hostcall_resp_append_header,
        checkFn: host.hostcall_resp_check_header,
        getFn: host.hostcall_resp_get_header_values,
        keysFn: utility.resp_get_header_names,
        removeFn: host.hostcall_resp_remove_header,
        setFn: host.hostcall_resp_set_header
      });
    }
  }
  class EdgioRequestHeaders extends EdgioHeaders {
    constructor(requestId, headers) {
      super(requestId, headers, {
        appendFn: host.hostcall_req_append_header,
        checkFn: host.hostcall_req_check_header,
        getFn: host.hostcall_req_get_header_values,
        keysFn: utility.req_get_header_names,
        removeFn: host.hostcall_req_remove_header,
        setFn: host.hostcall_req_set_header
      });
    }
  }
  class HeadersInternal {
    constructor() {
      __publicField(this, "appendFn", (_requestId, key, value) => {
        if (!this._headers[key])
          this._headers[key] = [];
        this._headers[key].push(value);
      });
      __publicField(this, "checkFn", (_requestId, key) => {
        return !!this._headers[key];
      });
      __publicField(this, "getFn", (_requestId, key) => {
        if (!this._headers[key])
          return null;
        return this._headers[key].join(", ");
      });
      __publicField(this, "getRawFn", () => {
        return this._headers;
      });
      __publicField(this, "keysFn", (_requestId) => {
        return Object.keys(this._headers);
      });
      __publicField(this, "removeFn", (_requestId, key) => {
        delete this._headers[key];
      });
      __publicField(this, "setFn", (_requestId, key, value) => {
        this._headers[key] = [value];
      });
      this._headers = {};
    }
  }
  globalThis.Headers = class Headers extends EdgioHeaders {
    constructor(headers) {
      const _headersInstance = new HeadersInternal();
      super(0, headers, {
        appendFn: _headersInstance.appendFn.bind(_headersInstance),
        checkFn: _headersInstance.checkFn.bind(_headersInstance),
        getFn: _headersInstance.getFn.bind(_headersInstance),
        keysFn: _headersInstance.keysFn.bind(_headersInstance),
        removeFn: _headersInstance.removeFn.bind(_headersInstance),
        setFn: _headersInstance.setFn.bind(_headersInstance)
      });
      __publicField(this, "getRaw", () => {
        return this._headersInstance.getRawFn();
      });
      this._headersInstance = _headersInstance;
    }
  };
  globalThis.Request = class {
    constructor(input, options) {
      this[Options] = options || {};
      if (typeof options?.edgio?.id === "number") {
        this[EdgioId] = options?.edgio?.id;
        this[ReqRespHeaders] = new EdgioRequestHeaders(this[EdgioId]);
        return;
      }
      if (typeof input !== "string") {
        throw new Error(`"string" type is accepted for the input parameter, not '${typeof input}'`);
      }
      const url = input;
      if (this[Options].method !== void 0 && typeof this[Options].method !== "string") {
        throw new Error(`options.method must be type 'undefined' or 'string', not '${typeof this[Options].method}'`);
      }
      const method = this[Options].method || "GET";
      this[EdgioId] = host.hostcall_req_create(method, url);
      this[ReqRespHeaders] = new EdgioRequestHeaders(this[EdgioId], this[Options]?.headers || {});
      const body = this[Options].body;
      delete this[Options].body;
      this[BodyUsed] = false;
      if (body) {
        if (method === "GET" || method === "HEAD") {
          throw new Error("Request with GET/HEAD method cannot have body.");
        }
        if (typeof body === "string") {
          host.hostcall_debug(`new Request(${this[EdgioId]}, string: ${body})`);
          host.hostcall_req_set_body_from_string(this[EdgioId], body);
        } else if (body instanceof ArrayBuffer) {
          host.hostcall_debug(`new Request(ArrayBuffer: len=${body.byteLength})`);
          host.hostcall_req_set_body_from_array_buffer(this[EdgioId], body);
        } else if (ArrayBuffer.isView(body)) {
          host.hostcall_debug(`new Request(TypedArray: len=${body.byteLength})`);
          host.hostcall_req_set_body_from_array_buffer(this[EdgioId], body.buffer);
        } else {
          host.hostcall_debug(`new Request(other: ${body.toString()})`);
          host.hostcall_req_set_body_from_string(this[EdgioId], body.toString());
        }
      }
    }
    async arrayBuffer() {
      const stream = new EdgioReadableRequestStream(this[EdgioId]);
      const body = await stream.getReader().read();
      if (body.done) {
        return new ArrayBuffer(0);
      }
      this[BodyUsed] = true;
      return body.value.buffer;
    }
    blob() {
      throw new Error(`${InternalErrorPrefix}The 'blob' method is not supported by the Request class.`);
    }
    get body() {
      if (this.method === "GET" || this.method === "HEAD") {
        return null;
      }
      return new EdgioReadableRequestStream(this[EdgioId]);
    }
    get bodyUsed() {
      return this[BodyUsed];
    }
    get cache() {
      throw new Error(`${InternalErrorPrefix}The 'cache' property is not supported by the Request class.`);
    }
    get credentials() {
      throw new Error(`${InternalErrorPrefix}The 'credentials' property is not supported by the Request class.`);
    }
    clone() {
      throw new Error(`${InternalErrorPrefix}The 'clone' method is not supported by the Request class.`);
    }
    get destination() {
      throw new Error(`${InternalErrorPrefix}The 'destination' property is not supported by the Request class.`);
    }
    formData() {
      throw new Error(`${InternalErrorPrefix}The 'formData' method is not supported by the Request class.`);
    }
    get headers() {
      return this[ReqRespHeaders];
    }
    get integrity() {
      throw new Error(`${InternalErrorPrefix}The 'integrity' property is not supported by the Request class.`);
    }
    async json() {
      return JSON.parse(await this.text());
    }
    get method() {
      return host.hostcall_req_get_method(this[EdgioId]);
    }
    set method(method) {
      return host.hostcall_req_set_method(this[EdgioId], method);
    }
    get mode() {
      throw new Error(`${InternalErrorPrefix}The 'mode' property is not supported by the Request class.`);
    }
    get redirect() {
      throw new Error(`${InternalErrorPrefix}The 'redirect' property is not supported by the Request class.`);
    }
    get referrer() {
      throw new Error(`${InternalErrorPrefix}The 'referrer' property is not supported by the Request class.`);
    }
    get referrerPolicy() {
      throw new Error(`${InternalErrorPrefix}The 'referrerPolicy' property is not supported by the Request class.`);
    }
    get signal() {
      throw new Error(`${InternalErrorPrefix}The 'signal' property is not supported by the Request class.`);
    }
    async text() {
      const stream = new EdgioReadableRequestStream(this[EdgioId]);
      const body = await stream.getReader().read();
      if (body.done) {
        return "";
      }
      this[BodyUsed] = true;
      return new TextDecoder(UTF_8).decode(body.value);
    }
    get url() {
      return host.hostcall_req_get_uri(this[EdgioId]);
    }
    set url(uri) {
      return host.hostcall_req_set_uri(this[EdgioId], uri);
    }
    get path() {
      return host.hostcall_req_get_path(this[EdgioId]);
    }
    get edgioId() {
      return this[EdgioId];
    }
    toJSON() {
      return {
        method: this.method,
        url: this.url,
        headers: this.headers
      };
    }
    cloneWithoutBody() {
      const clone_id = host.hostcall_req_clone_without_body(this[EdgioId]);
      const req = new Request(null, {
        edgio: {
          id: clone_id
        }
      });
      return req;
    }
  };
  globalThis.Response = class {
    constructor(body, optionsOrResponse) {
      this[BodyUsed] = false;
      this[BodyDefined] = false;
      this[Redirected] = false;
      this[Url] = null;
      if (typeof optionsOrResponse?.edgio?.id === "number") {
        this[EdgioId] = optionsOrResponse?.edgio?.id;
        this[ReqRespHeaders] = new EdgioResponseHeaders(this[EdgioId]);
        host.hostcall_debug(`_edgioNew Response: ${this[EdgioId]}`);
        this[BodyDefined] = true;
        return;
      }
      if (optionsOrResponse instanceof Response) {
        const clone = optionsOrResponse.cloneWithoutBody();
        this[EdgioId] = clone[EdgioId];
        this[Headers] = clone[Headers];
        this[Redirected] = clone[Redirected];
        this[Url] = clone[Url];
      } else {
        this[Options] = optionsOrResponse || {};
        if (isNaN(this[Options].status))
          this[Options].status = 200;
        if (this[Options].status < 200 || this[Options].status > 599 || this[Options].status === 204 || this[Options].status === 304) {
          throw new Error(`The status provided ${this[Options].status} must be >= 200 and <= 599, and not 204 or 304.`);
        }
        this[EdgioId] = host.hostcall_resp_create(this[Options].status);
        this[ReqRespHeaders] = new EdgioResponseHeaders(this[EdgioId], this[Options]?.headers || {});
      }
      if (body) {
        if (typeof body === "string") {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(string: ${body})`);
          host.hostcall_resp_set_body_from_string(this[EdgioId], body);
        } else if (body instanceof ArrayBuffer) {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(ArrayBuffer: len=${body.byteLength})`);
          host.hostcall_resp_set_body_from_array_buffer(this[EdgioId], body);
        } else if (ArrayBuffer.isView(body)) {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(TypedArray: len=${body.byteLength})`);
          host.hostcall_resp_set_body_from_array_buffer(this[EdgioId], body.buffer);
        } else {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(other: ${body.toString()})`);
          host.hostcall_resp_set_body_from_string(this[EdgioId], body.toString());
        }
      }
    }
    async arrayBuffer() {
      if (this[BodyDefined]) {
        this[BodyUsed] = false;
        const body = await this.body.getReader().read();
        if (body.done) {
          return new ArrayBuffer(0);
        }
        return body.value.buffer;
      }
      return new ArrayBuffer(0);
    }
    blob() {
      throw new Error(`${InternalErrorPrefix}The 'blob' method is not supported by the Response class.`);
    }
    get body() {
      if (this[BodyDefined]) {
        return new EdgioReadableResponseStream(this[EdgioId]);
      }
      return null;
    }
    get bodyUsed() {
      return this[BodyUsed];
    }
    clone() {
      throw new Error(`${InternalErrorPrefix}The 'clone' method is not supported by the Response class.`);
    }
    formData() {
      throw new Error(`${InternalErrorPrefix}The 'formData' method is not supported by the Response class.`);
    }
    get headers() {
      return this[ReqRespHeaders];
    }
    async json() {
      return JSON.parse(await this.text());
    }
    get ok() {
      let status = this.status;
      return status >= 200 && status < 300;
    }
    static redirect(url, status) {
      return new Response(void 0, { headers: { location: url }, status: status || 302 });
    }
    set redirected(newRedirected) {
      this[Redirected] = newRedirected;
    }
    get redirected() {
      return this[Redirected];
    }
    get status() {
      return host.hostcall_resp_get_status(this[EdgioId]);
    }
    get statusText() {
      return host.hostcall_resp_get_reason(this[EdgioId]);
    }
    async text() {
      this[BodyUsed] = true;
      if (!this[BodyDefined]) {
        return "";
      }
      const body = await this.body.getReader().read();
      return new TextDecoder(UTF_8).decode(body.value);
    }
    get type() {
      throw new Error(`${InternalErrorPrefix}The 'type' property is not supported by the Response class.`);
    }
    get url() {
      return this[Url];
    }
    get edgioId() {
      return this[EdgioId];
    }
    toJSON() {
      return {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers
      };
    }
    cloneWithoutBody() {
      const clone_id = host.hostcall_resp_clone_without_body(this[EdgioId]);
      const resp = new Response(null, {
        edgio: {
          id: clone_id
        }
      });
      resp[Url] = this[Url];
      resp[Redirected] = this[Redirected];
      return resp;
    }
  };
  globalThis.OpaqueRedirect = class extends globalThis.Response {
    constructor(edgioId, url) {
      super("", { edgio: { id: edgioId } });
      this[ReqRespHeaders] = {
        append: () => {
        },
        delete: () => {
        },
        entries: () => {
          return [];
        },
        forEach: () => {
        },
        get: () => {
          return null;
        },
        has: () => {
          return false;
        },
        keys: () => {
          return [];
        },
        set: () => {
        },
        values: () => {
          return [];
        }
      };
      this[Url] = url;
    }
    get ok() {
      return false;
    }
    get status() {
      return 0;
    }
  };
  class ResponseError extends Error {
    constructor(responseErrorCode) {
      super();
      this[ErrorCode] = responseErrorCode;
    }
    get code() {
      return this[ErrorCode];
    }
    get message() {
      return host.hostcall_resp_get_error_code_message(this[ErrorCode]);
    }
    toString() {
      return `${this.message} (code: ${this.code})`;
    }
  }
  function EdgioDict(namespace) {
    const namespaces = { namespace };
    const dictProxy = new Proxy(namespaces, {
      get(target, property) {
        if (property === "get") {
          return function(key) {
            return host.hostcall_dict_get(target.namespace, key);
          };
        }
        if (property === "getBase64Decoded") {
          return function(key) {
            return new Uint8Array(host.hostcall_dict_get_base64_decoded(target.namespace, key));
          };
        }
        if (property === "has") {
          return function(key) {
            return host.hostcall_dict_check(target.namespace, key);
          };
        }
        if (property === "keys") {
          return function() {
            return utility.dict_get_keys(target.namespace);
          };
        }
        return host.hostcall_dict_get(target.namespace, property);
      },
      getOwnPropertyDescriptor(target, property) {
        return {
          value: host.hostcall_dict_get(target.namespace, property),
          writable: false,
          enumerable: true,
          configurable: true
        };
      },
      defineProperty(_target, _key, _descriptor) {
        return false;
      },
      deleteProperty(_target, _property) {
        return false;
      },
      has(target, property) {
        return host.hostcall_dict_check(target.namespace, property);
      },
      ownKeys(target) {
        return utility.dict_get_keys(target.namespace);
      }
    });
    return dictProxy;
  }
  class EdgioSet {
    constructor(namespace) {
      this[Namespace] = namespace;
    }
    has(key) {
      return host.hostcall_unique_set_check(this[Namespace], key);
    }
    keys() {
      return utility.unique_set_get_keys(this[Namespace]);
    }
    toJSON() {
      return this.keys();
    }
  }
  class EdgioMetrics {
    startTimer(index) {
      return host.hostcall_metrics_start_timer(index);
    }
    stopTimer(index) {
      return host.hostcall_metrics_stop_timer(index);
    }
    add(index, value) {
      return host.hostcall_metrics_add(index, value);
    }
  }
  function wrapFunctionCallWithMetrics(invocationCountId, microsecondTimerId, fn, ...args) {
    host.hostcall_metrics_add(invocationCountId, 1);
    host.hostcall_metrics_start_timer(microsecondTimerId);
    try {
      return fn(...args);
    } finally {
      host.hostcall_metrics_stop_timer(microsecondTimerId);
    }
  }
  const orignalJSONparse = JSON.parse;
  const originalJSONstringify = JSON.stringify;
  globalThis.JSON = {
    parse: (...args) => {
      return wrapFunctionCallWithMetrics(WASM_METRIC_JSON_PARSE_INVOCATION_TOTAL, WASM_METRIC_JSON_PARSE_MICROSECONDS_TOTAL, orignalJSONparse, ...args);
    },
    stringify: (...args) => {
      return wrapFunctionCallWithMetrics(WASM_METRIC_JSON_STRINGIFY_INVOCATION_TOTAL, WASM_METRIC_JSON_STRINGIFY_MICROSECONDS_TOTAL, originalJSONstringify, ...args);
    }
  };
  globalThis.module = {};
  globalThis.__dirname = "/";
  globalThis.__filename = "/index.js";
  globalThis.global = globalThis;
  globalThis.TextDecoder = class TextDecoder {
    constructor(encoding) {
      this[Encoding] = encoding || UTF_8;
    }
    get fatal() {
      return false;
    }
    set fatal(value) {
      if (value) {
        throw new Error("TextDecoder.fatal is not supported");
      }
    }
    decode(buffer) {
      if (!buffer) {
        return "";
      }
      const array_buffer = ArrayBuffer.isView(buffer) ? buffer.buffer : buffer;
      if (!(array_buffer instanceof ArrayBuffer)) {
        throw new Error(`Decoding supported for ArrayBuffer, TypedArray and DataView, not ${typeof buffer}`);
      }
      return utility.text_decoder_decode(this[Encoding], array_buffer);
    }
  };
  function encode_value_to_string(value) {
    switch (typeof value) {
      case "undefined":
        return "";
      case "string":
        return value;
      default: {
        if (value === null) {
          return "null";
        }
        return value.toString();
      }
    }
  }
  globalThis.TextEncoder = class TextEncoder {
    constructor() {
    }
    encode(str) {
      const value = encode_value_to_string(str);
      if (typeof value !== "string") {
        return new Uint8Array(0);
      }
      return new Uint8Array(utility.text_encoder_encode(value));
    }
    encodeInto(str, array) {
      if (!(array instanceof Uint8Array)) {
        throw new Error("TextEncoder.encodeInto requires an Uint8Array");
      }
      const value = encode_value_to_string(str);
      if (array.byteLength === 0 || typeof value !== "string") {
        return {
          read: 0,
          written: 0
        };
      }
      return utility.text_encoder_encode_into(value, array);
    }
    get encoding() {
      return UTF_8;
    }
  };
  let waiting_on_main_promise = false;
  let unhandled_rejection = null;
  let pending_fetches = /* @__PURE__ */ new Map();
  let respond_with_finished = false;
  let wait_until_used_counter = 0;
  let wait_until_finished_counter = 0;
  function expect_number_of_args(args, expected) {
    if (args.length !== expected) {
      throw new Error(`Expected ${expected} arguments, got ${args.length}`);
    }
  }
  function expect_min_number_of_args(args, expected) {
    if (args.length < expected) {
      throw new Error(`Expected at least ${expected} arguments, got ${args.length}`);
    }
  }
  function create_context(environmentVars) {
    return {
      environmentVars,
      origins: globalThis[Origins],
      requestVars: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_USRVAR),
      geo: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_GEO),
      device: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_WURFL),
      client: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_VIRT),
      metrics: new EdgioMetrics(),
      respondWith: function(responsePromise) {
        expect_number_of_args(arguments, 1);
        if (responsePromise instanceof Response) {
          let response = responsePromise;
          host.hostcall_debug("sdk.js respondWith: got response object, handle synchronously and return");
          host.hostcall_resp_send_to_client(response.edgioId);
          respond_with_finished = true;
          return void 0;
        }
        host.hostcall_debug("sdk.js respondWith: resolving response promise");
        Promise.resolve(responsePromise).then((response) => {
          host.hostcall_resp_send_to_client(response.edgioId);
          respond_with_finished = true;
          return response;
        }).catch((err) => {
          respond_with_finished = false;
          throw new Error("Failed to resolve respondWith promise: " + err);
        });
      },
      waitUntil: function(promise) {
        expect_number_of_args(arguments, 1);
        ++wait_until_used_counter;
        Promise.resolve(promise).then((response) => {
          ++wait_until_finished_counter;
          return response;
        }).catch((err) => {
          ++wait_until_finished_counter;
          throw new Error("Failed to resolve waitUntil promise: " + err);
        });
      }
    };
  }
  function parseCookie(cookie) {
    const parts = cookie.split("=");
    const key = parts[0].trim();
    const value = parts[1];
    return { key, value };
  }
  function processSetCookies(options, response) {
    let deduplicatedCookies = {};
    const existingCookies = options.headers.cookie;
    if (existingCookies) {
      const individualCookies = existingCookies.split(";");
      for (let i = 0; i < individualCookies.length; i++) {
        const { key, value } = parseCookie(individualCookies[i]);
        deduplicatedCookies[key] = value;
      }
    }
    let setCookies = response.headers.get("set-cookie") || [];
    if (!Array.isArray(setCookies)) {
      setCookies = [setCookies];
    }
    for (let i = 0; i < setCookies.length; i++) {
      const { key, value } = parseCookie(setCookies[i].split(";")[0]);
      deduplicatedCookies[key] = value;
    }
    const keys = Object.keys(deduplicatedCookies);
    if (keys.length > 0) {
      options.headers.cookie = "";
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = deduplicatedCookies[key];
        options.headers.cookie += `${key}=${value}${i < keys.length - 1 ? "; " : ""}`;
      }
    }
  }
  async function handleRedirect(originalUrl, options, redirectedCount, response) {
    const MAX_REDIRECTS = 5;
    const location = response.headers.get("location");
    if ([301, 302, 303, 307, 308].indexOf(response.status) < 0 || !location) {
      response[Url] = originalUrl;
      response.redirected = redirectedCount > 0;
      return response;
    }
    const redirect = options.redirect;
    if (redirect === "error") {
      throw new Error("redirect");
    }
    if (redirect === "manual") {
      return new globalThis.OpaqueRedirect(response.edgioId, originalUrl);
    }
    if (++redirectedCount > MAX_REDIRECTS) {
      throw new Error(`fetch(${originalUrl}) exceeded the limit of ${MAX_REDIRECTS} redirects.`);
    }
    processSetCookies(options, response);
    const newResponse = await issueFetch(location, options, redirectedCount);
    return newResponse;
  }
  async function issueFetch(urlOrRequest, options, redirectedCount) {
    let req;
    if (urlOrRequest instanceof Request) {
      req = urlOrRequest;
    } else {
      if (typeof urlOrRequest !== "string") {
        if (typeof urlOrRequest.toString !== "function" || urlOrRequest.toString() === "[object Object]") {
          throw new Error('Invalid "url" argument in fetch() function. The "url" argument must be a string, a Request object, or an object where toString() returns the url.');
        }
        urlOrRequest = urlOrRequest.toString();
      }
      req = new Request(urlOrRequest, options);
    }
    const origin = options.edgio.origin;
    try {
      host.hostcall_req_set_fetch_origin(req.edgioId, origin);
    } catch {
      throw new Error(`Invalid edgio.origin: "${origin}". Must be one of: ${globalThis[Origins].keys().join(", ")}`);
    }
    if (options.edgio.timeout) {
      const timeout = parseInt(options.edgio.timeout);
      if (isNaN(timeout)) {
        throw new Error(`Invalid edgio.timeout specified. Expected timeout in milliseconds as an integer.`);
      }
      try {
        host.hostcall_req_set_fetch_timeout(req.edgioId, timeout);
      } catch {
        throw new Error(`Failed to set fetch timeout on request.`);
      }
    }
    host.hostcall_req_fetch_async(req.edgioId);
    let resolve;
    let reject;
    const promise = new Promise((promise_resolve, promise_reject) => {
      resolve = promise_resolve;
      reject = promise_reject;
    });
    pending_fetches.set(req.edgioId, {
      promise,
      resolve,
      reject
    });
    const request_url = req.url;
    const response = await promise;
    return handleRedirect(request_url, options, redirectedCount, response);
  }
  globalThis.fetch = async function(urlOrRequest, options) {
    expect_min_number_of_args(arguments, 1);
    options = options || {};
    if (!options.redirect) {
      options.redirect = "follow";
    }
    if (!options.headers) {
      options.headers = {};
    }
    if (!options.edgio) {
      options.edgio = {};
    }
    const validRedirects = ["error", "follow", "manual"];
    if (validRedirects.indexOf(options.redirect) < 0) {
      throw new Error(`redirect must be one of "${validRedirects.join(", ")}", not "${options.redirect}"`);
    }
    if (!options.edgio.origin) {
      throw new Error(`edgio.origin must be specified as a fetch option. Must be one of: ${globalThis[Origins].keys().join(",")}`);
    }
    return issueFetch(urlOrRequest, options, 0);
  };
  function main(edgioRequestId2) {
    const environmentVars = EdgioDict(ENV_VAR_NAMESPACE_EDGIO_CONFIG);
    const path = environmentVars["__EDGE_FUNCTION_PATH__"];
    const edgeFunction = edgeFunctions.get(path);
    if (!edgeFunction) {
      throw new Error(`No edge function found for path: ${path}`);
    }
    function jobs_are_not_pending() {
      return respond_with_finished && wait_until_finished_counter >= wait_until_used_counter;
    }
    globalThis[Origins] = new EdgioSet(ENV_VAR_NAMESPACE_EDGIO_ORIGINS);
    const req = new Request(null, {
      edgio: {
        id: edgioRequestId2
      }
    });
    const context = create_context(environmentVars);
    const main_promise = edgeFunction().bind(globalThis)(req, context);
    while (true) {
      while (!waiting_on_main_promise) {
        if (main_promise instanceof Promise) {
          waiting_on_main_promise = true;
          main_promise.then(() => {
            waiting_on_main_promise = false;
          }).catch((err) => {
            waiting_on_main_promise = false;
            unhandled_rejection = err;
          });
        }
        if (jobs_are_not_pending()) {
          host.hostcall_debug("breaking the loop - no more jobs (1)");
          return;
        }
      }
      host.hostcall_debug("Executing pending jobs...");
      utility.execute_pending();
      if (unhandled_rejection) {
        const err = unhandled_rejection;
        unhandled_rejection = null;
        throw err;
      }
      if (pending_fetches.size === 0) {
        if (!waiting_on_main_promise) {
          return;
        }
      } else {
        const [is_response, req_id, resp_id_or_err_code] = host.hostcall_resp_await_next();
        host.hostcall_debug(`sdk.js->hostcall_resp_await_next: is_response(${is_response}), req_id(${req_id}), resp_id_or_err_code(${resp_id_or_err_code})`);
        const pending_fetch = pending_fetches.get(req_id);
        if (!pending_fetch) {
          throw new Error(`No pending fetch for ID ${req_id}`);
        }
        pending_fetches.delete(req_id);
        const { resolve, reject } = pending_fetch;
        if (is_response) {
          host.hostcall_debug("sdk.js: creating Response");
          const resp = new Response(null, {
            edgio: {
              id: resp_id_or_err_code
            }
          });
          resolve(resp);
        } else {
          host.hostcall_debug("sdk.js: creating ResponseError");
          const err = new ResponseError(resp_id_or_err_code);
          reject(err);
        }
      }
      if (jobs_are_not_pending()) {
        host.hostcall_debug("breaking the loop - no more jobs (2)");
        return;
      }
    }
  }
  main(edgioRequestId);
};
//# sourceMappingURL=sdk.js.map
